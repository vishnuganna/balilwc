import { LightningElement, track, api } from "lwc";
import deleteLabel from "@salesforce/label/c.delete";
import criticalVulnerabilityHeaderUrl from "@salesforce/label/c.criticalVulnerabilityHeaderUrl";
import edit from "@salesforce/label/c.edit";
import addVulnerabilityButton from "@salesforce/label/c.addVulnerabilityButton";
import vulnerablityTitle from "@salesforce/label/c.vulnerablityTitle";
import cancelLabel from "@salesforce/label/c.cancel";
import saveLabel from "@salesforce/label/c.save";
import criticalDescLabel from "@salesforce/label/c.Description";
import criticalDescTitleLabel from "@salesforce/label/c.criticalVulnerablityTitle";
import createCriticalVulnerabilityApi from "@salesforce/apex/CriticalVulnerabilityController.saveVulnerabilityData";
import getCriticalVulnerabilityApi from "@salesforce/apex/CriticalVulnerabilityController.getVulnerabilityData";
import showLess from "@salesforce/label/c.showLess";
import showMore from "@salesforce/label/c.showMore";
import { ShowToastEvent } from "lightning/platformShowToastEvent";
import successheader from "@salesforce/label/c.success_header";
import errorheader from "@salesforce/label/c.error_header";
import errormsg from "@salesforce/label/c.Record_error_message";
import successmsg from "@salesforce/label/c.Record_success_message";
import yes from "@salesforce/label/c.yes";
import DeleteVulnerabilityHeader from "@salesforce/label/c.DeleteVulnerabilityHeader";
import deleteCompetitionMessage from "@salesforce/label/c.deleteCompetitionMessage";
import no from "@salesforce/label/c.no";
import cancel from "@salesforce/label/c.cancel";
import close from "@salesforce/label/c.close";
import deletemsg from "@salesforce/label/c.Record_delete_message";
import deleteCriticalVulnerability from "@salesforce/apex/CriticalVulnerabilityController.deleteCriticalVulnerability";
import Description_cannot_exceed_32k_characters from "@salesforce/label/c.maxLimitError";
import Trend_cannot_exceed_80_characters from "@salesforce/label/c.Trend_cannot_exceed_80_characters";
import { loadStyle } from "lightning/platformResourceLoader";
import styles from "@salesforce/resourceUrl/cssLibrary";
import Vulnerability from "@salesforce/label/c.CriticalVulnerability";
import ErrorOccured from "@salesforce/label/c.ErrorOccured";

export default class CriticalVulnerability extends LightningElement {
    @api goldsheetId;
    @track showCreateButton = false;
    @track isButtonDisabled = true;
    title = "";
    description = "";
    descriptionField;
    noOfLines = 5;
    isShowMoreExist = false;

    @track hasAccess = false;
    @track isEditable = false;
    @track showSavedState = false;
    @track cvShowSpinner = false;

    @track criticalVulnerablityTitle = "";
    @track criticalVulnerablityDesc = "";
    @track disabledSaveButton = true;
    @track showMaxLimitErrorTitle = false;

    @track ShowModal = false;
    @track isDeletable = false;
    @track isUpdatable = false;
    @track showMaxLimitError = false;
    editstateRfs = null;

    label = {
        criticalVulnerabilityHeaderUrl,
        criticalDescLabel,
        criticalDescTitleLabel,
        deleteLabel,
        edit,
        vulnerablityTitle,
        saveLabel,
        cancelLabel,
        addVulnerabilityButton,
        showLess,
        showMore,
        successheader,
        errorheader,
        errormsg,
        successmsg,
        Trend_cannot_exceed_80_characters,
        close,
        yes,
        no,
        cancel,
        deletemsg,
        Description_cannot_exceed_32k_characters,
        DeleteVulnerabilityHeader,
        deleteCompetitionMessage,
        Vulnerability, //KFS-2766
        ErrorOccured //KFS-2766
    };

    rfsDetails = this.getNewRfsDetails();

    getNewRfsDetails() {
        return {
            vulnerablity: {
                redFlagSelected: false,
                strengthSelected: false,
                noneSelected: true,
                fieldApiName: "vulnerablity"
            }
        };
    }

    makeFormEditable() {
        this.isEditable = true;
        this.showSavedState = false;
        this.showCreateButton = false;
    }

    addCriticalVulnerablity() {
        this.isEditable = true;
        this.showSavedState = false;
        this.showCreateButton = false;
        this.rfsDetails = this.getNewRfsDetails();
    }

    connectedCallback() {
        getCriticalVulnerabilityApi({ goldsheetId: this.goldsheetId })
            .then(res => {
                this.hasAccess = res.hasEditAccess;
                this.updateData(res);
                this.handleView(res);
                this.validateForm(res.title);
                if (res.rfsMarkerWrapper.length > 0) {
                    this.rfsDetails = this.convertMarkerMap(res.rfsMarkerWrapper);
                    this.editstateRfs = JSON.parse(JSON.stringify(this.rfsDetails));
                }
            })
            .catch(() => {
                this.dispatchEvent(
                    new ShowToastEvent({
                        title: this.label.Vulnerability, //KFS-2766
                        message: this.label.ErrorOccured, //KFS-2766
                        variant: "error"
                    })
                );
            });
    }

    assignMapForRFS(flag) {
        this.rfsDetails.vulnerablity = {
            redFlagSelected: flag.redFlagSelected,
            strengthSelected: flag.strengthSelected,
            noneSelected: flag.redFlagSelected && flag.strengthSelected,
            fieldApiName: "vulnerablity"
        };

        this.editstateRfs = JSON.parse(JSON.stringify(this.rfsDetails));
    }

    convertMarkerMap(rfsMarkerWrapper) {
        const markers = rfsMarkerWrapper;
        const markersMap = this.getNewRfsDetails();
        markers.forEach(marker => {
            markersMap[marker.fieldApiName] = marker;
        });
        return markersMap;
    }

    updateData(res) {
        this.criticalVulnerablityTitle = res.title ? res.title : "";
        this.criticalVulnerablityDesc = res.description ? res.description : "";
        this.title = res.title ? res.title : "";
        this.description = res.description ? res.description : "";
    }

    handleView(response) {
        if (response.title) {
            this.showSavedState = true;
            this.showCreateButton = false;
            if (this.hasAccess) {
                this.isUpdatable = true;
                this.isDeletable = true;
            }
        } else {
            this.showSavedState = false;
            this.showCreateButton = true;
            this.isUpdatable = false;
            this.isDeletable = false;
        }
    }

    handleTitle(event) {
        this.title = event.target.value;
        if (this.title.length === 80) {
            this.showMaxLimitErrorTitle = true;
        } else {
            this.showMaxLimitErrorTitle = false;
        }

        this.validateForm(this.title);
    }

    handleDesc(event) {
        this.description = event.target.value;
        if (this.description.length === 32000) {
            this.showMaxLimitError = true;
        } else {
            this.showMaxLimitError = false;
        }
    }

    validateForm(value) {
        if (value && value.length > 1) {
            this.isButtonDisabled = false;
        } else {
            this.isButtonDisabled = true;
        }
        return this.isButtonDisabled;
    }

    handleSave() {
        this.cvShowSpinner = true;
        this.showMaxLimitError = false;
        this.showMaxLimitErrorTitle = false;

        let vulnerablityToSave = {
            title: this.title,
            description: this.description,
            goldsheetId: this.goldsheetId,
            hasEditAccess: this.hasAccess
        };
        createCriticalVulnerabilityApi({ inputString: JSON.stringify(vulnerablityToSave), rfsMap: this.rfsDetails })
            .then(res => {
                this.isEditable = false;
                this.cvShowSpinner = false;
                this.updateData(res);
                this.handleView(res);
                if (res.rfsMarkerWrapper.length > 0) {
                    this.rfsDetails = this.convertMarkerMap(res.rfsMarkerWrapper);
                    this.editstateRfs = JSON.parse(JSON.stringify(this.rfsDetails));
                }

                this.showToast(this.label.successheader, this.label.successmsg, "success");
            })
            .catch(() => {
                this.cvShowSpinner = false;
                this.isUpdatable = false;
                this.showToast(this.label.errorheader, this.label.errormsg, "error");
            });
    }

    cancel() {
        this.isEditable = false;
        this.showMaxLimitError = false;
        this.showMaxLimitErrorTitle = false;
        if (this.editstateRfs != null) {
            this.rfsDetails = JSON.parse(JSON.stringify(this.editstateRfs));
        } else {
            this.rfsDetails = this.getNewRfsDetails();
        }
        if (this.criticalVulnerablityTitle !== "") {
            this.showCreateButton = false;
            this.showSavedState = true;
            this.isUpdatable = true;
            this.isDeletable = true;
        } else {
            this.showCreateButton = true;
            this.showSavedState = false;
            this.isUpdatable = false;
            this.isDeletable = false;
        }
    }

    showToast(header, message, variant) {
        this.dispatchEvent(
            new ShowToastEvent({
                title: header,
                message: message,
                variant: variant
            })
        );
    }

    handleshowmoreless() {
        let clickedItem = this.template.querySelector(".showmore");

        if (clickedItem.innerText === this.label.showMore) {
            clickedItem.innerText = this.label.showLess;
            this.descriptionField.style.webkitLineClamp = "unset";
        } else {
            clickedItem.innerText = this.label.showMore;
            this.descriptionField.style.webkitLineClamp = this.noOfLines;
        }
    }

    renderedCallback() {
        loadStyle(this, styles);
        this.descriptionField = this.template.querySelector(".showdesc");
        if (this.descriptionField) {
            const divHeight = this.descriptionField.offsetHeight;
            const style = window.getComputedStyle(this.descriptionField);
            const lineHeight = parseInt(style.getPropertyValue("line-height"), 10);

            const existingNoOfLines = divHeight / lineHeight;

            if (existingNoOfLines < this.noOfLines) {
                this.isShowMoreExist = false;
            } else {
                this.isShowMoreExist = true;
                this.descriptionField.style.webkitLineClamp = this.noOfLines;
            }
        }
    }

    deleteVulnerability() {
        this.ShowModal = true;
    }

    closeModal() {
        this.ShowModal = false;
    }
    deleteModal() {
        this.ShowModal = false;

        deleteCriticalVulnerability({ goldsheetId: this.goldsheetId })
            .then(() => {
                this.dispatchEvent(
                    new ShowToastEvent({
                        title: this.label.successheader,
                        message: this.label.deletemsg,
                        variant: "success"
                    })
                );

                this.updateData({});
                this.validateForm(this.title);
                this.rfsDetails = this.getNewRfsDetails();
                this.editstateRfs = null;
                this.showSavedState = false;
                this.showCreateButton = true;
                this.isDeletable = false;
                this.isUpdatable = false;
            })
            .catch(() => {
                this.dispatchEvent(
                    new ShowToastEvent({
                        title: this.label.errorheader,
                        message: this.label.errormsg,
                        variant: "error"
                    })
                );
            });
    }

    //If marker updated then updated
    handleMarkerChange(event) {
        const eventChangedMarker = event.detail;
        const rfsDetailsUpdate = this.rfsDetails[eventChangedMarker.fieldApiName];
        Object.keys(rfsDetailsUpdate).forEach(key => {
            if (eventChangedMarker[key] !== undefined && eventChangedMarker[key] !== null) {
                rfsDetailsUpdate[key] = eventChangedMarker[key];
            }
        });
    }
}